1、熟练掌握单例模式的常见写法。
singleton模块代码

2、总结每种单例写法的优、缺点。
2.1、饿汉式
提前实例化对象，避免了线程安全问题
缺点：系统启动就实例化，占用了资源
2.2、懒汉式
在使用的时候在实例化，节省了资源
缺点：多线程下会有安全问题，同时判断对象是否创建也有一定的时间成本
2.3、静态内部类方式：推荐方式
利用了类加载机制，在类加载的过程中就执行了，所以不存在线程并发问题。
同时只要不使用内部类，JVM就不去加载这个单例类，也不会创建单例对象，从而实现懒加载。
2.4、枚举式
相对来说这种写法很简单，并且任何情况下都是单例的。
缺点：通过反射可以看出，对象创建是在静态块里生成的，也想单于是饿汉式，占用了资源
2.5、注册式
开始的时候将单例注入到容器中，使用的时候再根据key获取实例，这种方式可以很方方便的管理很单例对象，
也对用户隐藏了具体实现类，降低了耦合度。
缺点：存在线程并发问题

3、思考破坏单例模式的方式有哪些？并且归纳总结。
破坏单例的方式：反射，序列化，原型模式。
A、反射可以获取单例的私有化构造函数，破坏单例，需要在私有构造函数中预防单例攻击
B、对象在反序列化过程中，会先判断有没有构造函数，有(无论私不私有)就会初始化一个对象，这样就破坏了单例
   在执行完构造函数后，又会判断有没有readResolve方法，如果有，就直接反射回调改方法。所以只要复写了readResolve()方法，在反序列化的时就直接返回此方法指定的对象而不创建新对象。
C、原型模式是通过对象clone方法在内存中完成对象实例的复制，为了避免对单例的破坏，可以不实现Cloneable接口，或者在clone()方法中直接返回指定本对象。
对于枚举式单例不被攻击的原理
首先，Java语言不支持枚举类通过反射创建对象
其次，在反序列化的过程中，是通过读取内存中类的字节码对象和对象名称来获取对象实例的，由于字节码对象jvm中只会有一个，所以也是单例的。

4、梳理内部类的执行逻辑，并画出时序图
内部类执行逻辑：
静态内部类记载：外部类静态变量，外部类静态代码块，内部类静态成员，内部类静态代码块，
时序图